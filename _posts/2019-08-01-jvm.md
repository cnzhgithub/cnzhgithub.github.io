---
layout: post
title: 内存模型介绍
description: 内存分区介绍
tag: javase
---

# JVM内存模型介绍

### jvm内存空间分为堆内存，方法区栈内存3块区域，这篇博客主要介绍这3块区域
<![](/images/jvm.png)

#### 堆内存（heap）

堆是被所有**线程共享**的区域，实在虚拟机启动时创建的。堆里面存放的都是**对象的实例**（new 出来的对象都存在堆中）。
我们平常所说的垃圾回收，主要回收的就是堆区。为了提升垃圾回收的性能，又把堆分成两块区**新生代（young）**和**年老代（old）**，更细一点划分新生代又可划分为Eden区和2个Survivor区（From Survivor和To Survivor）。
<![](/images/jvm1.jpg)

**Eden：**新创建的对象存放在Eden区

 **From Survivor和To Survivor：**保存新生代gc后还存活的对象。（使用复制算法，导致有一个Survivor空间浪费）Hotspot虚拟机新生代Eden和Survivor的大小比值为4：1，因为有两个Survivor，所以Eden:From Survivor:To Survivor比值为8：1：1。

 **老年代：**对象存活时间比较长（经过多次新生代的垃圾收集，默认是15次）的对象则进入老年的。
 当堆中分配的对象实例过多，且大部分对象都在使用，就会报内存溢出异常（OutOfMemoneyError）。

#### 方法区（method area)

方法区是被所有**线程共享**区域，用于存放**已被虚拟机加载**的类信息，常量，静态变量等数据。被Java虚拟机描述为堆的一个逻辑部分。习惯是也叫它永久代（permanment generation）
永久代也会垃圾回收，主要针对常量池回收，类型卸载（比如反射生成大量的临时使用的Class等信息）。
常量池用于存放**编译期**生成的各种字节码和符号引用，常量池具有一定的动态性，里面可以存放编译期生成的常量；**运行期间**的常量也可以添加进入常量池中，比如string的intern()方法。
当方法区满时，无法在分配空间，就会抛出内存溢出的异常（OutOfMemoneyError）。
java8中已经没有方法区了，取而代之的是元空间（Metaspace）

#### 栈（stack)，分为虚拟机栈和本地方法栈

##### 虚拟机栈(jvm stack)

java虚拟机栈是**线程私有**，生命周期与线程相同。创建线程的时候就会创建一个java虚拟机栈。
虚拟机执行java程序的时候，每个方法都会创建一个栈帧，栈帧存放在java虚拟机栈中，通过压栈出栈的方式进行方法调用。
栈帧又分为一下几个区域：**局部变量表、操作数栈、动态连接、方法出口**等。
平时我们所说的变量存在栈中，这句话说的不太严谨，应该说局部变量存放在java虚拟机栈的局部变量表中。
java的8中基本类型的局部变量的值存放在虚拟机栈的局部变量表中，如果是引用型的变量，则只存储对象的引用地址。

##### 本地方法栈(native stack)

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。

#### 程序计数器(pc register)

程序计数器就是记录当前线程执行程序的位置，改变计数器的值来确定执行的下一条指令，比如循环、分支、方法跳转、异常处理，线程恢复都是依赖程序计数器来完成。
Java虚拟机多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。为了线程切换能恢复到正确的位置，每条线程都需要一个独立的程序计数器，所以它是**线程私有**的。
如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

#### 直接内存

**直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域**，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。
     JDK1.4加的NIO中，ByteBuffer有个方法是allocateDirect(int capacity) ，这是一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。
