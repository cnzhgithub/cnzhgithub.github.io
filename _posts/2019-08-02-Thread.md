---
layout: post
title: 线程和进程
description: 关于java线程和进程的介绍
tag: javase
---

# java线程和进程

### 进程

**进程就是一个执行中的程序实例**，每个进程都有自己独立的一块内存空间，一个进程中可以有多个线程。比如在Windows系统中，一个运行的xx.exe就是一个进程。每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。

进程可分为3个状态:就绪、执行、和阻塞

**就绪状态**(ready) :  当进程已分配到除CPU以外的所有必要资源后，只要在获得CPU，便可立即执行，进程这时的状态就称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将他们排成一个队列，称为就绪队列。

**执行状态**: 进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态；再多处理机系统中，则有多个进程处于执行状态

**阻塞状态**： 正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，亦即程序的执行受到阻塞，把这种暂停状态称为阻塞状态，有时也称为等待状态或封锁状态。

<![](/images/线程1.png)

### 线程

线程是指进程中的一个执行任务(控制单元)，一个进程中可以运行多个线程。有如下几个特点:

1）进程中负责程序执行的执行单元

2）依靠程序执行的顺序控制流，只能使用程序的资源和环境，共享进程的全部资源

3）有自己的堆栈和局部变量，没有单独的地址空间

4）CPU调度和分派的基本单位，持有程序计数器，寄存器，堆栈

#### java线程中共有如下几个状态:

**New（新生）**
 NEW(新建尚未运行/启动)

**Runnable（可运行）**
 处于可运行状态：正在运行*或准备运行*
 在线程对象上调用start方法后，相应线程便会进入Runnable状态，若被线程调度程序调度，这个线程便会成为当前运行（Running）的线程；

**Blocked（被阻塞）**
 阻塞状态，受阻塞并等待某个监视器锁的线程，处于这种状态。
 若一段代码被线程A “上锁” ，此时线程B尝试执行这段代码，线程B就会进入Blocked状态；

**Waiting（等待）**
 通过wait方法进入的等待
 当线程等待另一个线程通知线程调度器一个条件时，它本身就会进入Waiting状态；

**Time Waiting（计时等待也被称为阻塞）**
 通过sleep或wait timeout方法进入的限期等待的状态
 计时等待与等待的区别是，线程只等待一定的时间，若超时则不再等待；

**Terminated（被终止）**
 线程终止状态
 线程的run方法执行完毕或者由于一个未捕获的异常导致run方法意外终止会进入Terminated状态。

来张更直观的图

![](/images/线程2.png)

#### 关于一些控制线程的方法

#### start():

这是一个实例方法,启动一个线程，但是线程不是已启动就会执行,需要等待程序调度获得处理器资源。

**isAlive()**:

这是一个实例方法，判断一个线程是否还活着。

**sleep()**:

这是一个静态方法，使一个线程进入阻塞（等待）状态

**join()**：

这是一个实例方法，在A线程中对线程B调用join方法会导致A线程暂时处于waiting，等线程B运行完毕后再接着运行线程A。
也就是说，把当前线程还没执行的部分“接到”另一个线程后面去，另一个线程运行完毕后，当前线程再接着运行。

**yield()**:

这是一个静态方法，作用是让当前线程“让步”，目的是让其他线程有更大的可能被系统调度，这个方法不会释放锁。

yield() 的“让步”只是让一小会，一小会之后就接着工作了。
 yield操作时，线程还是Runnable状态。
